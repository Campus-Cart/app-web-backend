{"$message_type":"diagnostic","message":"not all trait items implemented, missing: `find_all_products`, `find_many_products`, `find_one_product`, `remove_product`, `update_product`, `add_category_by_product`","code":{"code":"E0046","explanation":"Items are missing in a trait implementation.\n\nErroneous code example:\n\n```compile_fail,E0046\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {}\n// error: not all trait items implemented, missing: `foo`\n```\n\nWhen trying to make some type implement a trait `Foo`, you must, at minimum,\nprovide implementations for all of `Foo`'s required methods (meaning the\nmethods that do not have default implementations), as well as any required\ntrait items like associated types or constants. Example:\n\n```\ntrait Foo {\n    fn foo();\n}\n\nstruct Bar;\n\nimpl Foo for Bar {\n    fn foo() {} // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/server.rs","byte_start":872,"byte_end":903,"line_start":33,"line_end":33,"column_start":1,"column_end":32,"is_primary":true,"text":[{"text":"impl ProductService for Product {","highlight_start":1,"highlight_end":32}],"label":"missing `find_all_products`, `find_many_products`, `find_one_product`, `remove_product`, `update_product`, `add_category_by_product` in implementation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Sophix\\OneDrive\\Desktop\\app-web-backend\\apps\\product\\target\\debug\\build\\product-abc6d98464514801\\out/product.rs","byte_start":15518,"byte_end":15698,"line_start":385,"line_end":388,"column_start":9,"column_end":83,"is_primary":false,"text":[{"text":"        async fn find_all_products(","highlight_start":9,"highlight_end":36},{"text":"            &self,","highlight_start":1,"highlight_end":19},{"text":"            request: tonic::Request<super::Empty>,","highlight_start":1,"highlight_end":51},{"text":"        ) -> std::result::Result<tonic::Response<super::Products>, tonic::Status>;","highlight_start":1,"highlight_end":83}],"label":"`find_all_products` from trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Sophix\\OneDrive\\Desktop\\app-web-backend\\apps\\product\\target\\debug\\build\\product-abc6d98464514801\\out/product.rs","byte_start":15707,"byte_end":15900,"line_start":389,"line_end":392,"column_start":9,"column_end":83,"is_primary":false,"text":[{"text":"        async fn find_many_products(","highlight_start":9,"highlight_end":37},{"text":"            &self,","highlight_start":1,"highlight_end":19},{"text":"            request: tonic::Request<super::FilterProductsDto>,","highlight_start":1,"highlight_end":63},{"text":"        ) -> std::result::Result<tonic::Response<super::Products>, tonic::Status>;","highlight_start":1,"highlight_end":83}],"label":"`find_many_products` from trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Sophix\\OneDrive\\Desktop\\app-web-backend\\apps\\product\\target\\debug\\build\\product-abc6d98464514801\\out/product.rs","byte_start":15909,"byte_end":16099,"line_start":393,"line_end":396,"column_start":9,"column_end":82,"is_primary":false,"text":[{"text":"        async fn find_one_product(","highlight_start":9,"highlight_end":35},{"text":"            &self,","highlight_start":1,"highlight_end":19},{"text":"            request: tonic::Request<super::FindOneProductDto>,","highlight_start":1,"highlight_end":63},{"text":"        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status>;","highlight_start":1,"highlight_end":82}],"label":"`find_one_product` from trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Sophix\\OneDrive\\Desktop\\app-web-backend\\apps\\product\\target\\debug\\build\\product-abc6d98464514801\\out/product.rs","byte_start":16108,"byte_end":16294,"line_start":397,"line_end":400,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        async fn remove_product(","highlight_start":9,"highlight_end":33},{"text":"            &self,","highlight_start":1,"highlight_end":19},{"text":"            request: tonic::Request<super::FindOneProductDto>,","highlight_start":1,"highlight_end":63},{"text":"        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;","highlight_start":1,"highlight_end":80}],"label":"`remove_product` from trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Sophix\\OneDrive\\Desktop\\app-web-backend\\apps\\product\\target\\debug\\build\\product-abc6d98464514801\\out/product.rs","byte_start":16303,"byte_end":16490,"line_start":401,"line_end":404,"column_start":9,"column_end":82,"is_primary":false,"text":[{"text":"        async fn update_product(","highlight_start":9,"highlight_end":33},{"text":"            &self,","highlight_start":1,"highlight_end":19},{"text":"            request: tonic::Request<super::UpdateProductDto>,","highlight_start":1,"highlight_end":62},{"text":"        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status>;","highlight_start":1,"highlight_end":82}],"label":"`update_product` from trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Sophix\\OneDrive\\Desktop\\app-web-backend\\apps\\product\\target\\debug\\build\\product-abc6d98464514801\\out/product.rs","byte_start":16499,"byte_end":16694,"line_start":405,"line_end":408,"column_start":9,"column_end":80,"is_primary":false,"text":[{"text":"        async fn add_category_by_product(","highlight_start":9,"highlight_end":42},{"text":"            &self,","highlight_start":1,"highlight_end":19},{"text":"            request: tonic::Request<super::CreateCategoryDto>,","highlight_start":1,"highlight_end":63},{"text":"        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;","highlight_start":1,"highlight_end":80}],"label":"`add_category_by_product` from trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"implement the missing item: `fn find_all_products(&'life0 self, _: tonic::Request<product::Empty>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<Products>, Status>> + Send + 'async_trait)>> { todo!() }`","code":null,"level":"help","spans":[{"file_name":"src/server.rs","byte_start":2904,"byte_end":2904,"line_start":84,"line_end":84,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"fn find_all_products(&'life0 self, _: tonic::Request<product::Empty>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<Products>, Status>> + Send + 'async_trait)>> { todo!() }\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"implement the missing item: `fn find_many_products(&'life0 self, _: tonic::Request<FilterProductsDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<Products>, Status>> + Send + 'async_trait)>> { todo!() }`","code":null,"level":"help","spans":[{"file_name":"src/server.rs","byte_start":2904,"byte_end":2904,"line_start":84,"line_end":84,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"fn find_many_products(&'life0 self, _: tonic::Request<FilterProductsDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<Products>, Status>> + Send + 'async_trait)>> { todo!() }\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"implement the missing item: `fn find_one_product(&'life0 self, _: tonic::Request<FindOneProductDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Product>, Status>> + Send + 'async_trait)>> { todo!() }`","code":null,"level":"help","spans":[{"file_name":"src/server.rs","byte_start":2904,"byte_end":2904,"line_start":84,"line_end":84,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"fn find_one_product(&'life0 self, _: tonic::Request<FindOneProductDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Product>, Status>> + Send + 'async_trait)>> { todo!() }\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"implement the missing item: `fn remove_product(&'life0 self, _: tonic::Request<FindOneProductDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Empty>, Status>> + Send + 'async_trait)>> { todo!() }`","code":null,"level":"help","spans":[{"file_name":"src/server.rs","byte_start":2904,"byte_end":2904,"line_start":84,"line_end":84,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"fn remove_product(&'life0 self, _: tonic::Request<FindOneProductDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Empty>, Status>> + Send + 'async_trait)>> { todo!() }\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"implement the missing item: `fn update_product(&'life0 self, _: tonic::Request<UpdateProductDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Product>, Status>> + Send + 'async_trait)>> { todo!() }`","code":null,"level":"help","spans":[{"file_name":"src/server.rs","byte_start":2904,"byte_end":2904,"line_start":84,"line_end":84,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"fn update_product(&'life0 self, _: tonic::Request<UpdateProductDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Product>, Status>> + Send + 'async_trait)>> { todo!() }\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null},{"message":"implement the missing item: `fn add_category_by_product(&'life0 self, _: tonic::Request<CreateCategoryDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Empty>, Status>> + Send + 'async_trait)>> { todo!() }`","code":null,"level":"help","spans":[{"file_name":"src/server.rs","byte_start":2904,"byte_end":2904,"line_start":84,"line_end":84,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"}","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"fn add_category_by_product(&'life0 self, _: tonic::Request<CreateCategoryDto>) -> Pin<Box<(dyn std::future::Future<Output = Result<tonic::Response<product::Empty>, Status>> + Send + 'async_trait)>> { todo!() }\n","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0046]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: not all trait items implemented, missing: `find_all_products`, `find_many_products`, `find_one_product`, `remove_product`, `update_product`, `add_category_by_product`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc/server.rs:33:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m33\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mimpl ProductService for Product {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmissing `find_all_products`, `find_many_products`, `find_one_product`, `remove_product`, `update_product`, `add_category_by_product` in implementation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m::: \u001b[0m\u001b[0mC:\\Users\\Sophix\\OneDrive\\Desktop\\app-web-backend\\apps\\product\\target\\debug\\build\\product-abc6d98464514801\\out/product.rs:385:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m385\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        async fn find_all_products(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m386\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            &self,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m387\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            request: tonic::Request<super::Empty>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ) -> std::result::Result<tonic::Response<super::Products>, tonic::Status>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|__________________________________________________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`find_all_products` from trait\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m389\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        async fn find_many_products(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m390\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            &self,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m391\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            request: tonic::Request<super::FilterProductsDto>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m392\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ) -> std::result::Result<tonic::Response<super::Products>, tonic::Status>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|__________________________________________________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`find_many_products` from trait\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m393\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        async fn find_one_product(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m394\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            &self,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m395\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            request: tonic::Request<super::FindOneProductDto>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m396\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_________________________________________________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`find_one_product` from trait\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m397\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        async fn remove_product(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m398\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            &self,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m399\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            request: tonic::Request<super::FindOneProductDto>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m400\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_______________________________________________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`remove_product` from trait\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m401\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        async fn update_product(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m402\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            &self,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m403\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            request: tonic::Request<super::UpdateProductDto>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m404\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ) -> std::result::Result<tonic::Response<super::Product>, tonic::Status>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_________________________________________________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`update_product` from trait\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        async fn add_category_by_product(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m406\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            &self,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m407\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            request: tonic::Request<super::CreateCategoryDto>,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m408\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_______________________________________________________________________________-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m`add_category_by_product` from trait\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `DateTime<Utc>: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/server.rs","byte_start":2757,"byte_end":2766,"line_start":77,"line_end":77,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"            .bind(&timestamp)","highlight_start":20,"highlight_end":29}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: Encode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/server.rs","byte_start":2751,"byte_end":2755,"line_start":77,"line_end":77,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(&timestamp)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  <&'a str as Encode<'a, sqlx::Any>>\n  <&'q [u8] as Encode<'q, sqlx::Any>>\n  <&T as Encode<'q, DB>>\n  <&[T] as Encode<'q, Postgres>>\n  <&[u8] as Encode<'_, Postgres>>\n  <&str as Encode<'_, Postgres>>\n  <Box<[u8]> as Encode<'_, Postgres>>\n  <Box<str> as Encode<'_, Postgres>>\nand 34 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&DateTime<Utc>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs","byte_start":2937,"byte_end":2951,"line_start":81,"line_end":81,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `DateTime<Utc>: Encode<'_, Postgres>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc/server.rs:77:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(&timestamp)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Encode<'_, Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: Encode<'_, Postgres>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\u001b[0m\n\u001b[0m             <&'a str as Encode<'a, sqlx::Any>>\u001b[0m\n\u001b[0m             <&'q [u8] as Encode<'q, sqlx::Any>>\u001b[0m\n\u001b[0m             <&T as Encode<'q, DB>>\u001b[0m\n\u001b[0m             <&[T] as Encode<'q, Postgres>>\u001b[0m\n\u001b[0m             <&[u8] as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m             <&str as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m             <Box<[u8]> as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m             <Box<str> as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m           and 34 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: required for `&DateTime<Utc>` to implement `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs:81:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `DateTime<Utc>: sqlx::Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/server.rs","byte_start":2757,"byte_end":2766,"line_start":77,"line_end":77,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"            .bind(&timestamp)","highlight_start":20,"highlight_end":29}],"label":"the trait `sqlx::Type<Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: sqlx::Type<Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/server.rs","byte_start":2751,"byte_end":2755,"line_start":77,"line_end":77,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(&timestamp)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Type<DB>`:\n  <&T as sqlx::Type<DB>>\n  <() as sqlx::Type<Postgres>>\n  <(T1, T2) as sqlx::Type<Postgres>>\n  <(T1, T2, T3) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4, T5) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as sqlx::Type<Postgres>>\nand 41 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&DateTime<Utc>` to implement `sqlx::Type<Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs","byte_start":2954,"byte_end":2962,"line_start":81,"line_end":81,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `DateTime<Utc>: sqlx::Type<Postgres>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc/server.rs:77:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(&timestamp)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `sqlx::Type<Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: sqlx::Type<Postgres>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `sqlx::Type<DB>`:\u001b[0m\n\u001b[0m             <&T as sqlx::Type<DB>>\u001b[0m\n\u001b[0m             <() as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4, T5) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4, T5, T6) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4, T5, T6, T7) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m           and 41 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: required for `&DateTime<Utc>` to implement `sqlx::Type<Postgres>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs:81:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `DateTime<Utc>: Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/server.rs","byte_start":2788,"byte_end":2797,"line_start":78,"line_end":78,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"            .bind(&timestamp)","highlight_start":20,"highlight_end":29}],"label":"the trait `Encode<'_, Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: Encode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/server.rs","byte_start":2782,"byte_end":2786,"line_start":78,"line_end":78,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(&timestamp)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Encode<'q, DB>`:\n  <&'a str as Encode<'a, sqlx::Any>>\n  <&'q [u8] as Encode<'q, sqlx::Any>>\n  <&T as Encode<'q, DB>>\n  <&[T] as Encode<'q, Postgres>>\n  <&[u8] as Encode<'_, Postgres>>\n  <&str as Encode<'_, Postgres>>\n  <Box<[u8]> as Encode<'_, Postgres>>\n  <Box<str> as Encode<'_, Postgres>>\nand 34 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&DateTime<Utc>` to implement `Encode<'_, Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs","byte_start":2937,"byte_end":2951,"line_start":81,"line_end":81,"column_start":32,"column_end":46,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":32,"highlight_end":46}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `DateTime<Utc>: Encode<'_, Postgres>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc/server.rs:78:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(&timestamp)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `Encode<'_, Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: Encode<'_, Postgres>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `Encode<'q, DB>`:\u001b[0m\n\u001b[0m             <&'a str as Encode<'a, sqlx::Any>>\u001b[0m\n\u001b[0m             <&'q [u8] as Encode<'q, sqlx::Any>>\u001b[0m\n\u001b[0m             <&T as Encode<'q, DB>>\u001b[0m\n\u001b[0m             <&[T] as Encode<'q, Postgres>>\u001b[0m\n\u001b[0m             <&[u8] as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m             <&str as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m             <Box<[u8]> as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m             <Box<str> as Encode<'_, Postgres>>\u001b[0m\n\u001b[0m           and 34 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: required for `&DateTime<Utc>` to implement `Encode<'_, Postgres>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs:81:32\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `DateTime<Utc>: sqlx::Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/server.rs","byte_start":2788,"byte_end":2797,"line_start":78,"line_end":78,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"            .bind(&timestamp)","highlight_start":20,"highlight_end":29}],"label":"the trait `sqlx::Type<Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: sqlx::Type<Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/server.rs","byte_start":2782,"byte_end":2786,"line_start":78,"line_end":78,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(&timestamp)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Type<DB>`:\n  <&T as sqlx::Type<DB>>\n  <() as sqlx::Type<Postgres>>\n  <(T1, T2) as sqlx::Type<Postgres>>\n  <(T1, T2, T3) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4, T5) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4, T5, T6) as sqlx::Type<Postgres>>\n  <(T1, T2, T3, T4, T5, T6, T7) as sqlx::Type<Postgres>>\nand 41 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&DateTime<Utc>` to implement `sqlx::Type<Postgres>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs","byte_start":2954,"byte_end":2962,"line_start":81,"line_end":81,"column_start":49,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":49,"highlight_end":57}],"label":"required by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `DateTime<Utc>: sqlx::Type<Postgres>` is not satisfied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc/server.rs:78:20\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m78\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .bind(&timestamp)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `sqlx::Type<Postgres>` is not implemented for `DateTime<Utc>`, which is required by `&DateTime<Utc>: sqlx::Type<Postgres>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `sqlx::Type<DB>`:\u001b[0m\n\u001b[0m             <&T as sqlx::Type<DB>>\u001b[0m\n\u001b[0m             <() as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4, T5) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4, T5, T6) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m             <(T1, T2, T3, T4, T5, T6, T7) as sqlx::Type<Postgres>>\u001b[0m\n\u001b[0m           and 41 others\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: required for `&DateTime<Utc>` to implement `sqlx::Type<Postgres>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\Sophix\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\sqlx-core-0.7.4\\src\\query.rs:81:49\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m81\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn bind<T: 'q + Send + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Query::<'q, DB, <DB as HasArguments<'q>>::Arguments>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 5 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0046, E0277.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0046, E0277.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0046`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0046`.\u001b[0m\n"}
